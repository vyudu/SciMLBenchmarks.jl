---
title: Testing the scaling of non-spatial methods in JumpProcesses
author: Vincent Du
---

```julia
using JumpProcesses, Plots, StableRNGs, Random, BenchmarkTools, Catalyst
```
# Model Description and Setup
Here we will implement the method from [1] for different numbers of reaction channels (ranging from 1000 to 1,000,000) and benchmark the performance of JumpProcesses.jl's non-spatial aggregators (Direct(), DirectCR(), NRM(), CCNRM()). 


We create a very simple reaction network.
```julia
rn = @reaction_network begin
    @parameters kA kB
    kA, 0 --> A
    kB, 0 --> B
end
```

Below we define the function that we will use to generate the jump problems. 
```julia
    # z   A     B
u0 = [1., 1, 1]
p = (kA = 1.0, kB = 2.0) 
rng = StableRNG(53124)
rateA(u, p, t) = p.kA * u[1]
rateB(u, p, t) = p.kB * u[1]

# Our affect resamples u[1] to effectively resample the next time-to-reaction. This is the 
# simplest way to get random updates on the times, since we don't resample times
# when the propensities are updated. 
affectA!(integrator) = (integrator.u[1] = randexp(rng); integrator.u[2] += 1)
affectB!(integrator) = (integrator.u[1] = randexp(rng); integrator.u[3] += 1)

function generateJumpProblem(method, N::Int64, end_time) 
    depgraph = Vector{Vector{Int64}}()
    jumpvec = Vector{ConstantRateJump}()

    for i in 1:N
        # We make each reaction affect the rates of 10 others, so there are 10 updates per jump. 
        push!(depgraph, rand(rng, 1:N, 10))
        iseven(i) ? push!(jumpvec, ConstantRateJump(rateA, affectA!)) : 
            push!(jumpvec, ConstantRateJump(rateB, affectB!))
    end

    jset = JumpSet((), jumpvec, nothing, nothing)
    dprob = DiscreteProblem(u0, (0., end_time), p)
    jump_prob = JumpProblem(dprob, method, jset; dep_graph = depgraph, save_positions = (false, false), rng)
    jump_prob
end
```

# Model Solution
Let's look at one example to make sure that our model seems reasonable. Since 
half of the reactions correspond to 0 --> A and half correspond to 0 --> B, 
and the 0 --> B rate constant is twice the 0 --> A rate constant, we'd expect 
that the A/B ratio would approach 1/2 as the simulation goes on. 

```julia
end_time = 5000.0; N = 10000
algs = [DirectCR(), CCNRM(), NRM()]
jprob = generateJumpProblem(algs[1], N, end_time)
sol = solve(jprob, SSAStepper(); saveat = end_time/200)
ABratio = [u[2]/u[3] for u in sol.u]
plt = plot(sol.t, ABratio, label="DirectCR()", title="A-to-B ratio")

for alg in algs[2:end]
    jprob = generateJumpProblem(alg, N, end_time)
    sol = solve(jprob, SSAStepper(); saveat = end_time/200)
    ABratio = [u[2]/u[3] for u in sol.u]
    plot!(plt, sol.t, ABratio, label="$alg")
end
```

# Benchmarking performance of the methods
We can now run the solvers and record the performance with `BenchmarkTools`.
Let's first create a `DiscreteCallback` to terminate simulations once we reach
`10^7` events:
```julia
@kwdef mutable struct EventCallback
    n::Int = 0
end

function (ecb::EventCallback)(u, t, integ)
    ecb.n += 1
    ecb.n == 10^7
end

function (ecb::EventCallback)(integ) 
    terminate!(integ)
    nothing
end
```

Next we create a function to run and save the benchmarking results. 
```julia
function benchmark_and_save!(bench_dict, end_times, Nv, algs)
    @assert length(end_times) == length(Nv)

    # callback for terminating simulations
    ecb = EventCallback()
    cb = DiscreteCallback(ecb, ecb)

    for (end_time, N) in zip(end_times, Nv)
        names = ["$s"[1:end-2] for s in algs]
        # benchmarking and saving
        benchmarks = Vector{BenchmarkTools.Trial}(undef, length(algs))

        # callback for terminating simulations
        for (i, alg) in enumerate(algs)
            name = names[i]
            println("benchmarking $name")
            jp = generateJumpProblem(alg, N, end_time)
            b = @benchmarkable solve($jp, SSAStepper(); saveat = tspan, callback) setup = (callback = deepcopy($cb)) samples = 1 seconds = 360
            bench_dict[name, N] = run(b)
        end
    end
end
```

Finally we create a function to plot the benchmarking results. 
```julia
function fetch_and_plot(bench_dict)
    names = unique([key[1] for key in keys(bench_dict)])
    Nv = sort(unique([key[2] for key in keys(bench_dict)]))

    plt1 = plot()
    plt2 = plot()

    medtimes = [Float64[] for i in 1:length(names)]
    for (i,name) in enumerate(names)
        for N in Nv
            try
                push!(medtimes[i], median(bench_dict[name, N]).time/1e9)
            catch
                break
            end
        end
        len = length(medtimes[i])
        plot!(plt1, Nv[1:len], medtimes[i], marker = :hex, label = name, lw = 2)
    end

    plot!(plt1, xlabel = "Number of reaction channels", ylabel = "Median time in seconds",
                legend = :bottomright)
end
```

We now run the benchmarks and plot the results. The number of reaction channels will range from 100 to 1,000,000. We see that we observe a similar scaling as [^1]
with the CCNRM() method being more efficient for systems with very many reaction 
channels. 

```julia
algs = [NRM(), CCNRM(), DirectCR()]
N = [100, 200, 500, 1000, 2000, 5000, 10000, 20000, 50000, 100000, 200000, 500000, 1000000]
bench_dict = Dict{Tuple{String, Int}, BenchmarkTools.Trial}()
end_times = 20000. * ones(length(N))
benchmark_and_save!(bench_dict, end_times, N, algs)
plt = fetch_and_plot(bench_dict)
```

### References
[^1]: Sanft, Kevin R and Othmer, Hans G. *Constant-complexity stochastic simulation algorithm with optimal binning*. J. Chem. Phys., 143(7), 11 pp. (2015).

```julia, echo = false
using SciMLBenchmarks
SciMLBenchmarks.bench_footer(WEAVE_ARGS[:folder], WEAVE_ARGS[:file])
```
